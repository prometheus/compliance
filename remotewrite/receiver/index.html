<!--
Copyright The Prometheus Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Remote-Write v2 — Test Matrix</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="color-scheme" content="light dark" />
  <style>
    html {
      scroll-behavior: smooth;
    }
    @keyframes progress-stripes {
      0% { background-position: 0 0; }
      100% { background-position: 40px 0; }
    }
    .progress-animated {
      background-image: linear-gradient(
        45deg,
        rgba(255, 255, 255, 0.15) 25%,
        transparent 25%,
        transparent 50%,
        rgba(255, 255, 255, 0.15) 50%,
        rgba(255, 255, 255, 0.15) 75%,
        transparent 75%,
        transparent
      );
      background-size: 40px 40px;
      animation: progress-stripes 1s linear infinite;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <main class="max-w-7xl mx-auto p-4 sm:p-6">
    <header class="mb-4 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <h1 class="text-xl font-semibold tracking-tight">Remote-Write v2 — Test Matrix</h1>
      <div class="flex items-center gap-2">
        <label class="cursor-pointer flex items-center gap-1.5 rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          <input id="hideSuccessCheckbox" type="checkbox" class="rounded" />
          Hide success
        </label>
        <label class="cursor-pointer flex items-center gap-1.5 rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          <input id="hideShouldFailsCheckbox" type="checkbox" class="rounded" />
          Hide SHOULD fails
        </label>
        <button id="reloadBtn" class="rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          Reload <span class="hidden sm:inline">results.json</span>
        </button>
        <label class="cursor-pointer rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          Load file…
          <input id="fileInput" type="file" accept=".json,.jsonl,.txt" class="sr-only" />
        </label>
      </div>
    </header>

    <!-- Incomplete Results Warning -->
    <div id="incompleteWarning" class="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg hidden">
      <div class="flex items-center">
        <svg class="w-5 h-5 text-yellow-600 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
        </svg>
        <div>
          <h3 class="text-sm font-semibold text-yellow-800">Results Incomplete</h3>
          <p class="text-sm text-yellow-700">The test suite may still be running or the results file may be corrupted.</p>
        </div>
      </div>
    </div>

    <section aria-label="Legend" class="mb-3 text-sm">
      <div class="flex flex-wrap items-center gap-2">
        <span class="inline-flex items-center gap-2">
          <span class="inline-block rounded px-2 py-0.5 bg-green-100 text-green-800 font-medium">PASS</span>
        </span>
        <span class="inline-flex items-center gap-2">
          <span class="inline-block rounded px-2 py-0.5 bg-red-100 text-red-800 font-medium">FAIL</span>
          <span class="text-slate-500">/</span>
          <span class="inline-block rounded px-2 py-0.5 bg-gray-300 text-gray-800 font-medium">FAIL (SHOULD/MAY)</span>
        </span>
        <span class="inline-block rounded px-2 py-0.5 bg-yellow-100 text-yellow-900 font-medium">SKIP</span>
        <span class="inline-block rounded px-2 py-0.5 bg-slate-100 text-slate-500 font-medium">—</span>
        <span id="summary" class="ml-2 text-slate-600"></span>
      </div>
    </section>

    <div id="tableWrap" class="overflow-x-auto rounded-lg border border-slate-200 bg-white">
      <table class="min-w-full text-sm">
        <thead class="bg-slate-50 text-left">
          <tr>
            <th class="sticky left-0 z-10 bg-slate-50 px-4 py-2 font-semibold">Test name</th>
            <th class="px-4 py-2 font-semibold">RFC Level</th>
            <!-- rw columns injected here -->
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot id="tfoot" class="bg-slate-100 border-t-2 border-slate-300">
        </tfoot>
      </table>
    </div>

    <p id="status" class="mt-3 text-sm text-slate-600"></p>

    <section id="testDetails" class="mt-8">
      <h2 class="text-lg font-semibold mb-4">Detailed Test Results</h2>
      <div id="testDetailsContent"></div>
    </section>
  </main>

  <!-- Back to Top Button -->
  <button id="backToTop" class="fixed bottom-6 right-6 bg-slate-800 hover:bg-slate-700 text-white p-3 rounded-full shadow-lg transition-all duration-300 opacity-0 pointer-events-none z-50">
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
    </svg>
  </button>

  <script>
    // ---------- Utilities ----------
    // STATUS defines the possible test result statuses.
    const STATUS = { PASS: 'pass', FAIL: 'fail', SKIP: 'skip' };
    // byAlpha provides alphanumeric comparison for sorting.
    const byAlpha = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });

    // toLinesOrArray parses JSON or NDJSON text into an array of event objects.
    function toLinesOrArray(text) {
      text = text.trim();
      if (!text) return [];
      try {
        const parsed = JSON.parse(text);
        if (Array.isArray(parsed)) return parsed;
        // allow { "events": [...] } or { "Events": [...] }
        if (parsed.events && Array.isArray(parsed.events)) return parsed.events;
        if (parsed.Events && Array.isArray(parsed.Events)) return parsed.Events;
        // else fall through to NDJSON parse
      } catch (_) { /* NDJSON fallback below */ }
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const out = [];
      for (const line of lines) {
        try { out.push(JSON.parse(line)); } catch (e) { /* ignore junk lines */ }
      }
      return out;
    }

    // getAttrFor finds the most specific attribute value for a test name using longest-prefix matching.
    // Returns {value, pathLen, path} or null.
    function getAttrFor(testName, key, attrs) {
      let best = null;
      for (const a of attrs) {
        if (a.Key !== key) continue;
        const p = a.Test || '';
        if (testName === p || testName.startsWith(p + '/')) {
          const len = p.length;
          if (!best || len > best.pathLen) best = { value: a.Value, pathLen: len, path: p };
        }
      }
      return best;
    }

    // uniq returns an array with duplicate values removed.
    function uniq(arr) {
      return Array.from(new Set(arr));
    }

    // checkResultsCompleteness verifies if results.json contains a complete test run.
    // A complete results.json should end with a package-level pass/fail event with an Elapsed field.
    function checkResultsCompleteness(events) {
      if (!events || events.length === 0) return false;

      // Look for the final event - should be a package-level pass/fail event.
      const lastEvent = events[events.length - 1];

      // A complete results.json ends with an event that has:
      // - Action: "pass" or "fail".
      // - No Test field (package-level result).
      // - An Elapsed field.
      return lastEvent &&
             (lastEvent.Action === 'pass' || lastEvent.Action === 'fail') &&
             !lastEvent.Test &&
             typeof lastEvent.Elapsed !== 'undefined';
    }

    // showIncompleteWarning toggles the visibility of the incomplete results warning banner.
    function showIncompleteWarning(show) {
      const warningElement = document.getElementById('incompleteWarning');
      if (show) {
        warningElement.classList.remove('hidden');
      } else {
        warningElement.classList.add('hidden');
      }
    }

    // findRelatedTests finds tests with the same base name but different RW receivers.
    function findRelatedTests(currentTest, allTestDetails) {
      const currentBaseTest = removeOneSegment(currentTest.testName, currentTest.rw);
      return allTestDetails.filter(test => {
        const baseTest = removeOneSegment(test.testName, test.rw);
        return baseTest === currentBaseTest && test.rw !== currentTest.rw;
      });
    }

    // removeOneSegment removes exactly one segment equal to target from the path.
    // Prefers the last occurrence.
    function removeOneSegment(path, targetSegment) {
      const segs = path.split('/');
      let idx = -1;
      for (let i = segs.length - 1; i >= 0; i--) {
        if (segs[i] === targetSegment) { idx = i; break; }
      }
      if (idx === -1) return path;
      const without = segs.slice(0, idx).concat(segs.slice(idx + 1));
      return without.join('/');
    }

    // statusBadge generates an HTML badge for test status with optional link to detailed results.
    function statusBadge(status, rfcLevel, testName = null, rw = null) {
      const lvl = (rfcLevel || '').toUpperCase();
      let cls = 'bg-slate-100 text-slate-500';
      let label = '—';
      if (status === STATUS.PASS) { cls = 'bg-green-100 text-green-800'; label = 'PASS'; }
      else if (status === STATUS.FAIL) {
        if (lvl === 'SHOULD' || lvl === 'MAY') { cls = 'bg-gray-300 text-gray-800'; label = 'FAIL'; }
        else { cls = 'bg-red-100 text-red-800'; label = 'FAIL'; }
      } else if (status === STATUS.SKIP) { cls = 'bg-yellow-100 text-yellow-900'; label = 'SKIP'; }

      const badge = `<span class="inline-block rounded px-2 py-0.5 font-medium ${cls}">${label}</span>`;

      // If we have test name and rw, make it a clickable link
      if (testName && rw && status !== '—') {
        const targetId = `test-${encodeURIComponent(testName)}-${encodeURIComponent(rw)}`;
        return `<a href="#${targetId}" class="hover:opacity-75 transition-opacity">${badge}</a>`;
      }

      return badge;
    }

    // ---------- Core parsing & matrix build ----------
    // buildMatrix parses test events and constructs the test result matrix.
    // Returns {rows, rws, testDetails, startTime} containing organized test results.
    function buildMatrix(events) {
      const attrs = events.filter(e => e.Action === 'attr' && e.Test && e.Key && typeof e.Value !== 'undefined');
      const endEvents = events.filter(e =>
        e.Test && (e.Action === 'pass' || e.Action === 'fail' || e.Action === 'skip')
      );
      const outputEvents = events.filter(e => e.Action === 'output' && e.Test && e.Output);

      // Extract start time from the first event with a Time field
      let startTime = null;
      for (const ev of events) {
        if (ev.Time) {
          startTime = ev.Time;
          break;
        }
      }

      const rows = new Map(); // key -> { testName, rfcLevel, rfcAttrLen, resultsByRw: { rw -> status } }
      const allRws = new Set();
      const testDetails = new Map(); // key -> { testName, rw, status, rfcLevel, duration, output }

      for (const ev of endEvents) {
        const test = ev.Test;
        const rwAttr = getAttrFor(test, 'rw', attrs);
        const rfcAttr = getAttrFor(test, 'rfcLevel', attrs);
        if (!rwAttr || !rfcAttr) continue; // ignore tests without both attrs (direct or inherited)

        const rw = rwAttr.value;
        allRws.add(rw);

        // Collect test output for this specific test
        const testOutput = outputEvents
          .filter(e => e.Test === test)
          .map(e => e.Output)
          .join('');

        // Store detailed test information
        const detailKey = `${test}#${rw}`;
        testDetails.set(detailKey, {
          testName: test,
          rw: rw,
          status: ev.Action,
          rfcLevel: rfcAttr.value,
          duration: ev.Elapsed || 0,
          output: testOutput
        });

        // Row key is the test path with the rw segment removed once.
        const baseTest = removeOneSegment(test, rw);

        // Ensure row exists
        if (!rows.has(baseTest)) {
          rows.set(baseTest, {
            testName: baseTest,
            rfcLevel: rfcAttr.value,
            rfcAttrLen: rfcAttr.pathLen,
            resultsByRw: Object.create(null),
          });
        }

        const row = rows.get(baseTest);

        // Prefer the most specific rfcLevel (longest attr path)
        if (rfcAttr.pathLen > row.rfcAttrLen) {
          row.rfcLevel = rfcAttr.value;
          row.rfcAttrLen = rfcAttr.pathLen;
        }

        // Store status (if multiple results for same pair, prioritize FAIL > SKIP > PASS)
        const prev = row.resultsByRw[rw];
        const now = ev.Action;
        const rank = s => s === STATUS.FAIL ? 3 : (s === STATUS.SKIP ? 2 : (s === STATUS.PASS ? 1 : 0));
        if (!prev || rank(now) > rank(prev)) {
          row.resultsByRw[rw] = now;
        }
      }

      // Finalize arrays
      const rws = Array.from(allRws).sort(byAlpha);
      const rowList = Array.from(rows.values()).sort((a, b) => byAlpha(a.testName, b.testName));
      const detailsList = Array.from(testDetails.values());

      return { rows: rowList, rws, testDetails: detailsList, startTime };
    }

    // ---------- Rendering ----------
    // renderTestDetails renders the detailed test results section with filtering and cross-references.
    function renderTestDetails(testDetails, rws, allTestDetails = testDetails) {
      const content = document.getElementById('testDetailsContent');
      content.innerHTML = '';

      // Check if we should hide successful tests or SHOULD failures.
      const hideSuccess = document.getElementById('hideSuccessCheckbox').checked;
      const hideShouldFails = document.getElementById('hideShouldFailsCheckbox').checked;

      // Filter tests based on checkboxes.
      let filteredTestDetails = testDetails;

      if (hideSuccess) {
        filteredTestDetails = filteredTestDetails.filter(test => test.status !== STATUS.PASS);
      }

      if (hideShouldFails) {
        filteredTestDetails = filteredTestDetails.filter(test =>
          !(test.status === STATUS.FAIL && test.rfcLevel.toUpperCase() === 'SHOULD')
        );
      }

      // Group tests by RW.
      const testsByRw = {};
      for (const rw of rws) {
        testsByRw[rw] = [];
      }

      for (const test of filteredTestDetails) {
        if (testsByRw[test.rw]) {
          testsByRw[test.rw].push(test);
        }
      }

      // Sort tests within each RW group.
      for (const rw of rws) {
        testsByRw[rw].sort((a, b) => byAlpha(a.testName, b.testName));
      }

      // Render each RW group.
      for (const rw of rws) {
        if (testsByRw[rw].length === 0) continue;

        const section = document.createElement('div');
        section.className = 'mb-8';

        const header = document.createElement('h3');
        header.className = 'text-md font-semibold mb-4 text-slate-800';
        header.textContent = rw;
        section.appendChild(header);

        for (const test of testsByRw[rw]) {
          const testDiv = document.createElement('div');
          testDiv.className = 'mb-4 p-4 border border-slate-200 rounded-lg bg-white';
          testDiv.id = `test-${encodeURIComponent(test.testName)}-${encodeURIComponent(test.rw)}`;

          const durationText = test.duration > 0 ? ` (${test.duration.toFixed(3)}s)` : '';
          const statusClass = test.status === STATUS.PASS ? 'text-green-700' :
                              test.status === STATUS.FAIL ? 'text-red-700' : 'text-yellow-700';

          // Find related tests across different RW receivers.
          const relatedTests = findRelatedTests(test, allTestDetails);

          // Generate cross-reference section.
          let crossRefSection = '';
          if (relatedTests.length > 0) {
            // Group by status.
            const passingTests = relatedTests.filter(t => t.status === STATUS.PASS);
            const failingTests = relatedTests.filter(t => t.status === STATUS.FAIL);
            const skippingTests = relatedTests.filter(t => t.status === STATUS.SKIP);

            const statusGroups = [];
            if (passingTests.length > 0) {
              const links = passingTests.map(t =>
                `<a href="#test-${encodeURIComponent(t.testName)}-${encodeURIComponent(t.rw)}" class="text-green-700 hover:underline">${t.rw}</a>`
              ).join(', ');
              statusGroups.push(`PASSES on ${links}`);
            }
            if (failingTests.length > 0) {
              const links = failingTests.map(t => {
                const lvl = t.rfcLevel.toUpperCase();
                const linkColor = (lvl === 'SHOULD' || lvl === 'MAY') ? 'text-gray-600' : 'text-red-700';
                return `<a href="#test-${encodeURIComponent(t.testName)}-${encodeURIComponent(t.rw)}" class="${linkColor} hover:underline">${t.rw}</a>`;
              }).join(', ');
              statusGroups.push(`FAILS on ${links}`);
            }
            if (skippingTests.length > 0) {
              const links = skippingTests.map(t =>
                `<a href="#test-${encodeURIComponent(t.testName)}-${encodeURIComponent(t.rw)}" class="text-yellow-700 hover:underline">${t.rw}</a>`
              ).join(', ');
              statusGroups.push(`SKIPPED on ${links}`);
            }

            if (statusGroups.length > 0) {
              crossRefSection = `
                <div class="mt-3 pt-3 border-t border-slate-200">
                  <p class="text-xs text-slate-600">This test ${statusGroups.join(' and ')}.</p>
                </div>
              `;
            }
          }

          testDiv.innerHTML = `
            <div class="flex items-start justify-between mb-2">
              <div>
                <h4 class="font-mono text-sm font-medium text-slate-900">${test.testName}</h4>
                <div class="flex items-center gap-2 mt-1">
                  ${statusBadge(test.status, test.rfcLevel)}
                  <span class="text-xs text-slate-500">RFC Level: ${test.rfcLevel}</span>
                  <span class="text-xs text-slate-500 ${statusClass} font-medium">${test.status.toUpperCase()}${durationText}</span>
                </div>
              </div>
            </div>
            ${test.output ? `
              <div class="mt-3">
                <h5 class="text-xs font-medium text-slate-700 mb-1">Output:</h5>
                <pre class="text-xs bg-slate-50 p-2 rounded border overflow-x-auto text-slate-700">${test.output.trim()}</pre>
              </div>
            ` : ''}
            ${crossRefSection}
          `;

          section.appendChild(testDiv);
        }

        content.appendChild(section);
      }
    }

    // renderMatrix renders the main test matrix table and statistics footer.
    function renderMatrix({ rows, rws, testDetails, startTime }, isComplete = true) {
      const thead = document.querySelector('thead tr');
      // Wipe any prior rw headings.
      while (thead.children.length > 2) thead.removeChild(thead.lastChild);
      for (const rw of rws) {
        const th = document.createElement('th');
        th.className = 'px-4 py-2 font-semibold';
        th.textContent = rw;
        thead.appendChild(th);
      }

      const tbody = document.getElementById('tbody');
      tbody.innerHTML = '';

      for (const row of rows) {
        const tr = document.createElement('tr');
        tr.className = 'border-t border-slate-100 hover:bg-slate-50';

        // Test name (sticky first col on wide screens).
        const tdName = document.createElement('td');
        tdName.className = 'sticky left-0 z-[1] bg-white px-4 py-2 font-mono text-[13px]';
        tdName.textContent = row.testName;
        tr.appendChild(tdName);

        // rfcLevel.
        const tdLevel = document.createElement('td');
        tdLevel.className = 'px-4 py-2';
        const levelPill = document.createElement('span');
        levelPill.className = 'inline-block rounded bg-slate-100 px-2 py-0.5 font-medium text-slate-700';
        levelPill.textContent = row.rfcLevel;
        tdLevel.appendChild(levelPill);
        tr.appendChild(tdLevel);

        // Result cells per rw.
        for (const rw of rws) {
          const td = document.createElement('td');
          td.className = 'px-4 py-2 whitespace-nowrap';
          // Find the original test name from testDetails that matches this row and rw.
          const matchingDetail = testDetails.find(detail =>
            removeOneSegment(detail.testName, detail.rw) === row.testName && detail.rw === rw
          );
          const originalTestName = matchingDetail ? matchingDetail.testName : null;
          td.innerHTML = statusBadge(row.resultsByRw[rw], row.rfcLevel, originalTestName, rw);
          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      }

      // Calculate statistics for footer.
      const stats = {};
      for (const rw of rws) {
        stats[rw] = { mustPass: 0, mustFail: 0, shouldPass: 0, shouldFail: 0, mayPass: 0, mayFail: 0 };
      }

      for (const row of rows) {
        const rfcLevel = (row.rfcLevel || '').toUpperCase();
        for (const rw of rws) {
          const status = row.resultsByRw[rw];
          if (status === STATUS.PASS) {
            if (rfcLevel === 'MUST') stats[rw].mustPass++;
            else if (rfcLevel === 'SHOULD') stats[rw].shouldPass++;
            else if (rfcLevel === 'MAY') stats[rw].mayPass++;
          } else if (status === STATUS.FAIL) {
            if (rfcLevel === 'MUST') stats[rw].mustFail++;
            else if (rfcLevel === 'SHOULD') stats[rw].shouldFail++;
            else if (rfcLevel === 'MAY') stats[rw].mayFail++;
          }
        }
      }

      // Render footer with statistics.
      const tfoot = document.getElementById('tfoot');
      tfoot.innerHTML = '';

      const tr = document.createElement('tr');

      // Empty cell for test name column.
      const tdName = document.createElement('td');
      tdName.className = 'sticky left-0 z-[1] bg-slate-100 px-4 py-2 font-semibold text-sm';
      tdName.textContent = 'Statistics';
      tr.appendChild(tdName);

      // Empty cell for rfcLevel column.
      const tdLevel = document.createElement('td');
      tdLevel.className = 'px-4 py-2';
      tr.appendChild(tdLevel);

      // Statistics for each rw column.
      for (const rw of rws) {
        const td = document.createElement('td');
        td.className = 'px-4 py-2 text-xs text-slate-700';
        const s = stats[rw];
        const isCompliant = s.mustFail === 0 && s.mustPass > 0;
        const complianceLabel = isComplete
          ? (isCompliant
              ? '<div class="mt-2"><span class="inline-block rounded px-2 py-1 bg-green-100 text-green-800 font-semibold text-xs">COMPLIANT</span></div>'
              : '<div class="mt-2"><span class="inline-block rounded px-2 py-1 bg-red-100 text-red-800 font-semibold text-xs">NOT COMPLIANT</span></div>')
          : '';

        const mustTotal = s.mustPass + s.mustFail;
        const shouldTotal = s.shouldPass + s.shouldFail;

        const mustPassPercent = mustTotal > 0 ? (s.mustPass / mustTotal) * 100 : 0;
        const shouldPassPercent = shouldTotal > 0 ? (s.shouldPass / shouldTotal) * 100 : 0;

        const mustProgressBar = mustTotal > 0 ? `
          <div class="mb-2">
            <div class="text-xs font-semibold mb-1">MUST: ${s.mustPass} OK, ${s.mustFail} FAIL</div>
            <div class="w-full bg-gray-300 rounded-full h-2">
              <div class="${mustPassPercent === 100 ? 'bg-green-500' : 'bg-gray-600'}${!isComplete ? ' progress-animated' : ''} h-2 rounded-full" style="width: ${mustPassPercent}%"></div>
            </div>
          </div>
        ` : '';

        const shouldProgressBar = shouldTotal > 0 ? `
          <div class="mb-2">
            <div class="text-xs font-semibold mb-1">SHOULD: ${s.shouldPass} OK, ${s.shouldFail} FAIL</div>
            <div class="w-full bg-gray-300 rounded-full h-2">
              <div class="bg-gray-600${!isComplete ? ' progress-animated' : ''} h-2 rounded-full" style="width: ${shouldPassPercent}%"></div>
            </div>
          </div>
        ` : '';

        const mayTotal = s.mayPass + s.mayFail;
        const mayPassPercent = mayTotal > 0 ? (s.mayPass / mayTotal) * 100 : 0;
        const mayProgressBar = mayTotal > 0 ? `
          <div class="mb-2">
            <div class="text-xs font-semibold mb-1">MAY: ${s.mayPass} OK, ${s.mayFail} FAIL</div>
            <div class="w-full bg-gray-300 rounded-full h-2">
              <div class="bg-gray-600${!isComplete ? ' progress-animated' : ''} h-2 rounded-full" style="width: ${mayPassPercent}%"></div>
            </div>
          </div>
        ` : '';

        td.innerHTML = `
          <div class="space-y-1">
            ${mustProgressBar}
            ${shouldProgressBar}
            ${mayProgressBar}
            ${complianceLabel}
          </div>
        `;
        tr.appendChild(td);
      }

      tfoot.appendChild(tr);

      const summary = document.getElementById('summary');
      const testS = rows.length === 1 ? '' : 's';
      const receiverS = rws.length === 1 ? '' : 's';
      let summaryText = `${rows.length} test${testS} • ${rws.length} receiver${receiverS}`;
      if (startTime) {
        const date = new Date(startTime);
        const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: 'UTC', timeZoneName: 'short' };
        summaryText += ` • Started: ${date.toLocaleString('en-US', options)}`;
      }
      summary.textContent = summaryText;

      // Render detailed test results.
      renderTestDetails(testDetails, rws, testDetails);

      document.getElementById('status').textContent = rows.length
        ? 'Showing tests that have both an rw and an rfcLevel attribute (with attribute inheritance by prefix).'
        : 'No matching tests found (need both rw and rfcLevel).';
    }

    // ---------- Loading ----------
    // loadFromFetch loads test results from results.json via HTTP fetch.
    async function loadFromFetch() {
      const status = document.getElementById('status');
      status.textContent = 'Loading results.json…';
      const res = await fetch(`results.json?t=${Date.now()}`).catch(() => null);
      if (!res || !res.ok) throw new Error('results.json not found or not fetchable');
      const text = await res.text();
      const events = toLinesOrArray(text);

      // Check if results are complete and show warning if not.
      const isComplete = checkResultsCompleteness(events);
      showIncompleteWarning(!isComplete);

      const matrix = buildMatrix(events);
      renderMatrix(matrix, isComplete);
      status.textContent = 'Loaded results.json.';
    }

    // loadFromFile loads test results from a user-selected file.
    async function loadFromFile(file) {
      const status = document.getElementById('status');
      status.textContent = `Loading ${file.name}…`;
      const text = await file.text();
      const events = toLinesOrArray(text);

      // Check if results are complete and show warning if not.
      const isComplete = checkResultsCompleteness(events);
      showIncompleteWarning(!isComplete);

      const matrix = buildMatrix(events);
      renderMatrix(matrix, isComplete);
      status.textContent = `Loaded ${file.name}.`;
    }

    // ---------- Back to Top Button ----------
    // initBackToTop initializes the back-to-top button behavior.
    function initBackToTop() {
      const backToTopBtn = document.getElementById('backToTop');

      // Show/hide button based on scroll position.
      window.addEventListener('scroll', () => {
        if (window.scrollY > 300) {
          backToTopBtn.classList.remove('opacity-0', 'pointer-events-none');
          backToTopBtn.classList.add('opacity-100');
        } else {
          backToTopBtn.classList.add('opacity-0', 'pointer-events-none');
          backToTopBtn.classList.remove('opacity-100');
        }
      });

      // Scroll to top when clicked.
      backToTopBtn.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    }

    // ---------- Boot ----------
    // boot initializes the application on page load.
    (function boot() {
      // Initialize back to top button.
      initBackToTop();

      // Restore checkbox states from localStorage.
      const hideSuccessCheckbox = document.getElementById('hideSuccessCheckbox');
      const hideShouldFailsCheckbox = document.getElementById('hideShouldFailsCheckbox');

      const savedHideSuccess = localStorage.getItem('hideSuccess');
      if (savedHideSuccess === 'true') {
        hideSuccessCheckbox.checked = true;
      }

      const savedHideShouldFails = localStorage.getItem('hideShouldFails');
      if (savedHideShouldFails === 'true') {
        hideShouldFailsCheckbox.checked = true;
      }

      // Store current matrix data for re-rendering.
      let currentMatrix = null;

      // Add checkbox event listeners.
      const handleCheckboxChange = () => {
        // Save states to localStorage.
        localStorage.setItem('hideSuccess', hideSuccessCheckbox.checked.toString());
        localStorage.setItem('hideShouldFails', hideShouldFailsCheckbox.checked.toString());

        // Re-render test details if we have data.
        if (currentMatrix) {
          renderTestDetails(currentMatrix.testDetails, currentMatrix.rws, currentMatrix.testDetails);
        }
      };

      hideSuccessCheckbox.addEventListener('change', handleCheckboxChange);
      hideShouldFailsCheckbox.addEventListener('change', handleCheckboxChange);

      // Modified render function to store matrix data.
      const originalRenderMatrix = renderMatrix;
      renderMatrix = function(matrix) {
        currentMatrix = matrix;
        originalRenderMatrix(matrix);
      };

      // Try auto fetch; if it fails, leave UI ready for manual load.
      loadFromFetch().catch(() => {
        document.getElementById('status').textContent =
          'results.json not found via fetch — use "Load file…" or serve this directory.';
      });

      document.getElementById('reloadBtn').addEventListener('click', () => {
        loadFromFetch().catch(err => {
          document.getElementById('status').textContent =
            'Reload failed: results.json not found — use "Load file…".';
        });
      });

      document.getElementById('fileInput').addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (f) loadFromFile(f);
        e.target.value = '';
      });
    })();
  </script>
</body>
</html>

