<!--
Copyright The Prometheus Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Remote-Write v2 Sender — Test Matrix</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="color-scheme" content="light dark" />
  <style>
    html {
      scroll-behavior: smooth;
    }
    @keyframes progress-stripes {
      0% { background-position: 0 0; }
      100% { background-position: 40px 0; }
    }
    .progress-animated {
      background-image: linear-gradient(
        45deg,
        rgba(255, 255, 255, 0.15) 25%,
        transparent 25%,
        transparent 50%,
        rgba(255, 255, 255, 0.15) 50%,
        rgba(255, 255, 255, 0.15) 75%,
        transparent 75%,
        transparent
      );
      background-size: 40px 40px;
      animation: progress-stripes 1s linear infinite;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <main class="max-w-7xl mx-auto p-4 sm:p-6">
    <header class="mb-4 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <div>
        <h1 class="text-xl font-semibold tracking-tight">Remote-Write v2 Sender — Test Matrix</h1>
        <p class="text-sm text-slate-600 mt-1">Compliance tests for Prometheus Remote Write 2.0 senders</p>
      </div>
      <div class="flex items-center gap-2">
        <label class="cursor-pointer flex items-center gap-1.5 rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          <input id="hideSuccessCheckbox" type="checkbox" class="rounded" />
          Hide success
        </label>
        <label class="cursor-pointer flex items-center gap-1.5 rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          <input id="hideShouldFailsCheckbox" type="checkbox" class="rounded" />
          Hide SHOULD fails
        </label>
        <button id="reloadBtn" class="rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          Reload <span class="hidden sm:inline">results.json</span>
        </button>
        <label class="cursor-pointer rounded border border-slate-300 bg-white px-3 py-1.5 text-sm font-medium shadow-sm hover:bg-slate-50">
          Load file…
          <input id="fileInput" type="file" accept=".json,.jsonl,.txt" class="sr-only" />
        </label>
      </div>
    </header>

    <!-- Incomplete Results Warning -->
    <div id="incompleteWarning" class="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg hidden">
      <div class="flex items-center">
        <svg class="w-5 h-5 text-yellow-600 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
        </svg>
        <div>
          <h3 class="text-sm font-semibold text-yellow-800">Results Incomplete</h3>
          <p class="text-sm text-yellow-700">The test suite may still be running or the results file may be corrupted.</p>
        </div>
      </div>
    </div>

    <section aria-label="Legend" class="mb-3 text-sm">
      <div class="flex flex-wrap items-center gap-2">
        <span class="inline-flex items-center gap-2">
          <span class="inline-block rounded px-2 py-0.5 bg-green-100 text-green-800 font-medium">PASS</span>
        </span>
        <span class="inline-flex items-center gap-2">
          <span class="inline-block rounded px-2 py-0.5 bg-red-100 text-red-800 font-medium">FAIL</span>
          <span class="text-slate-500">/</span>
          <span class="inline-block rounded px-2 py-0.5 bg-gray-300 text-gray-800 font-medium">FAIL (SHOULD/MAY)</span>
        </span>
        <span class="inline-block rounded px-2 py-0.5 bg-yellow-100 text-yellow-900 font-medium">SKIP</span>
        <span class="inline-block rounded px-2 py-0.5 bg-slate-100 text-slate-500 font-medium">—</span>
        <span id="summary" class="ml-2 text-slate-600"></span>
      </div>
    </section>

    <div id="tableWrap" class="overflow-x-auto rounded-lg border border-slate-200 bg-white">
      <table class="min-w-full text-sm">
        <thead class="bg-slate-50 text-left">
          <tr>
            <th class="sticky left-0 z-10 bg-slate-50 px-4 py-2 font-semibold">Test name</th>
            <th class="px-4 py-2 font-semibold">RFC Level</th>
            <!-- sender columns injected here -->
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
        <tfoot id="tfoot" class="bg-slate-100 border-t-2 border-slate-300">
        </tfoot>
      </table>
    </div>

    <p id="status" class="mt-3 text-sm text-slate-600"></p>

    <section id="testDetails" class="mt-8">
      <h2 class="text-lg font-semibold mb-4">Detailed Test Results</h2>
      <div id="testDetailsContent"></div>
    </section>
  </main>

  <!-- Back to Top Button -->
  <button id="backToTop" class="fixed bottom-6 right-6 bg-slate-800 hover:bg-slate-700 text-white p-3 rounded-full shadow-lg transition-all duration-300 opacity-0 pointer-events-none z-50">
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
    </svg>
  </button>

  <script>
    // ---------- Utilities ----------
    const STATUS = { PASS: 'pass', FAIL: 'fail', SKIP: 'skip' };
    const byAlpha = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });

    function toLinesOrArray(text) {
      text = text.trim();
      if (!text) return [];
      try {
        const parsed = JSON.parse(text);
        if (Array.isArray(parsed)) return parsed;
        if (parsed.events && Array.isArray(parsed.events)) return parsed.events;
        if (parsed.Events && Array.isArray(parsed.Events)) return parsed.Events;
      } catch (_) { }
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const out = [];
      for (const line of lines) {
        try { out.push(JSON.parse(line)); } catch (e) { }
      }
      return out;
    }

    function getAttrFor(testName, key, attrs) {
      let best = null;
      for (const a of attrs) {
        if (a.Key !== key) continue;
        const p = a.Test || '';
        if (testName === p || testName.startsWith(p + '/')) {
          const len = p.length;
          if (!best || len > best.pathLen) best = { value: a.Value, pathLen: len, path: p };
        }
      }
      return best;
    }

    function checkResultsCompleteness(events) {
      if (!events || events.length === 0) return false;
      const lastEvent = events[events.length - 1];
      return lastEvent &&
             (lastEvent.Action === 'pass' || lastEvent.Action === 'fail') &&
             !lastEvent.Test &&
             typeof lastEvent.Elapsed !== 'undefined';
    }

    function showIncompleteWarning(show) {
      const warningElement = document.getElementById('incompleteWarning');
      if (show) {
        warningElement.classList.remove('hidden');
      } else {
        warningElement.classList.add('hidden');
      }
    }

    function findRelatedTests(currentTest, allTestDetails) {
      const currentBaseTest = removeOneSegment(currentTest.testName, currentTest.sender);
      return allTestDetails.filter(test => {
        const baseTest = removeOneSegment(test.testName, test.sender);
        return baseTest === currentBaseTest && test.sender !== currentTest.sender;
      });
    }

    function removeOneSegment(path, targetSegment) {
      const segs = path.split('/');
      let idx = -1;
      for (let i = segs.length - 1; i >= 0; i--) {
        if (segs[i] === targetSegment) { idx = i; break; }
      }
      if (idx === -1) return path;
      const without = segs.slice(0, idx).concat(segs.slice(idx + 1));
      return without.join('/');
    }

    function statusBadge(status, rfcLevel, testName = null, sender = null) {
      const lvl = (rfcLevel || '').toUpperCase();
      let cls = 'bg-slate-100 text-slate-500';
      let label = '—';
      if (status === STATUS.PASS) { cls = 'bg-green-100 text-green-800'; label = 'PASS'; }
      else if (status === STATUS.FAIL) {
        if (lvl === 'SHOULD' || lvl === 'MAY') { cls = 'bg-gray-300 text-gray-800'; label = 'FAIL'; }
        else { cls = 'bg-red-100 text-red-800'; label = 'FAIL'; }
      } else if (status === STATUS.SKIP) { cls = 'bg-yellow-100 text-yellow-900'; label = 'SKIP'; }

      const badge = `<span class="inline-block rounded px-2 py-0.5 font-medium ${cls}">${label}</span>`;

      if (testName && sender && status !== '—') {
        const targetId = `test-${encodeURIComponent(testName)}-${encodeURIComponent(sender)}`;
        return `<a href="#${targetId}" class="hover:opacity-75 transition-opacity">${badge}</a>`;
      }

      return badge;
    }

    // ---------- Core parsing & matrix build ----------
    function buildMatrix(events) {
      const attrs = events.filter(e => e.Action === 'attr' && e.Test && e.Key && typeof e.Value !== 'undefined');
      const endEvents = events.filter(e =>
        e.Test && (e.Action === 'pass' || e.Action === 'fail' || e.Action === 'skip')
      );
      const outputEvents = events.filter(e => e.Action === 'output' && e.Test && e.Output);

      let startTime = null;
      for (const ev of events) {
        if (ev.Time) {
          startTime = ev.Time;
          break;
        }
      }

      const rows = new Map();
      const allSenders = new Set();
      const testDetails = new Map();

      for (const ev of endEvents) {
        const test = ev.Test;
        const senderAttr = getAttrFor(test, 'sender', attrs);
        const rfcAttr = getAttrFor(test, 'rfcLevel', attrs);
        if (!senderAttr || !rfcAttr) continue;

        const sender = senderAttr.value;
        allSenders.add(sender);

        const testOutput = outputEvents
          .filter(e => e.Test === test)
          .map(e => e.Output)
          .join('');

        const detailKey = `${test}#${sender}`;
        testDetails.set(detailKey, {
          testName: test,
          sender: sender,
          status: ev.Action,
          rfcLevel: rfcAttr.value,
          duration: ev.Elapsed || 0,
          output: testOutput
        });

        const baseTest = removeOneSegment(test, sender);

        if (!rows.has(baseTest)) {
          rows.set(baseTest, {
            testName: baseTest,
            rfcLevel: rfcAttr.value,
            rfcAttrLen: rfcAttr.pathLen,
            resultsBySender: Object.create(null),
          });
        }

        const row = rows.get(baseTest);

        if (rfcAttr.pathLen > row.rfcAttrLen) {
          row.rfcLevel = rfcAttr.value;
          row.rfcAttrLen = rfcAttr.pathLen;
        }

        const prev = row.resultsBySender[sender];
        const now = ev.Action;
        const rank = s => s === STATUS.FAIL ? 3 : (s === STATUS.SKIP ? 2 : (s === STATUS.PASS ? 1 : 0));
        if (!prev || rank(now) > rank(prev)) {
          row.resultsBySender[sender] = now;
        }
      }

      const senders = Array.from(allSenders).sort(byAlpha);
      const rowList = Array.from(rows.values()).sort((a, b) => byAlpha(a.testName, b.testName));
      const detailsList = Array.from(testDetails.values());

      return { rows: rowList, senders, testDetails: detailsList, startTime };
    }

    // ---------- Rendering ----------
    function renderTestDetails(testDetails, senders, allTestDetails = testDetails) {
      const content = document.getElementById('testDetailsContent');
      content.innerHTML = '';

      const hideSuccess = document.getElementById('hideSuccessCheckbox').checked;
      const hideShouldFails = document.getElementById('hideShouldFailsCheckbox').checked;

      let filteredTestDetails = testDetails;

      if (hideSuccess) {
        filteredTestDetails = filteredTestDetails.filter(test => test.status !== STATUS.PASS);
      }

      if (hideShouldFails) {
        filteredTestDetails = filteredTestDetails.filter(test =>
          !(test.status === STATUS.FAIL && test.rfcLevel.toUpperCase() === 'SHOULD')
        );
      }

      const testsBySender = {};
      for (const sender of senders) {
        testsBySender[sender] = [];
      }

      for (const test of filteredTestDetails) {
        if (testsBySender[test.sender]) {
          testsBySender[test.sender].push(test);
        }
      }

      for (const sender of senders) {
        testsBySender[sender].sort((a, b) => byAlpha(a.testName, b.testName));
      }

      for (const sender of senders) {
        if (testsBySender[sender].length === 0) continue;

        const section = document.createElement('div');
        section.className = 'mb-8';

        const header = document.createElement('h3');
        header.className = 'text-md font-semibold mb-4 text-slate-800';
        header.textContent = sender;
        section.appendChild(header);

        for (const test of testsBySender[sender]) {
          const testDiv = document.createElement('div');
          testDiv.className = 'mb-4 p-4 border border-slate-200 rounded-lg bg-white';
          testDiv.id = `test-${encodeURIComponent(test.testName)}-${encodeURIComponent(test.sender)}`;

          const durationText = test.duration > 0 ? ` (${test.duration.toFixed(3)}s)` : '';
          const statusClass = test.status === STATUS.PASS ? 'text-green-700' :
                              test.status === STATUS.FAIL ? 'text-red-700' : 'text-yellow-700';

          const relatedTests = findRelatedTests(test, allTestDetails);

          let crossRefSection = '';
          if (relatedTests.length > 0) {
            const passingTests = relatedTests.filter(t => t.status === STATUS.PASS);
            const failingTests = relatedTests.filter(t => t.status === STATUS.FAIL);
            const skippingTests = relatedTests.filter(t => t.status === STATUS.SKIP);

            const statusGroups = [];
            if (passingTests.length > 0) {
              const links = passingTests.map(t =>
                `<a href="#test-${encodeURIComponent(t.testName)}-${encodeURIComponent(t.sender)}" class="text-green-700 hover:underline">${t.sender}</a>`
              ).join(', ');
              statusGroups.push(`PASSES on ${links}`);
            }
            if (failingTests.length > 0) {
              const links = failingTests.map(t => {
                const lvl = t.rfcLevel.toUpperCase();
                const linkColor = (lvl === 'SHOULD' || lvl === 'MAY') ? 'text-gray-600' : 'text-red-700';
                return `<a href="#test-${encodeURIComponent(t.testName)}-${encodeURIComponent(t.sender)}" class="${linkColor} hover:underline">${t.sender}</a>`;
              }).join(', ');
              statusGroups.push(`FAILS on ${links}`);
            }
            if (skippingTests.length > 0) {
              const links = skippingTests.map(t =>
                `<a href="#test-${encodeURIComponent(t.testName)}-${encodeURIComponent(t.sender)}" class="text-yellow-700 hover:underline">${t.sender}</a>`
              ).join(', ');
              statusGroups.push(`SKIPPED on ${links}`);
            }

            if (statusGroups.length > 0) {
              crossRefSection = `
                <div class="mt-3 pt-3 border-t border-slate-200">
                  <p class="text-xs text-slate-600">This test ${statusGroups.join(' and ')}.</p>
                </div>
              `;
            }
          }

          testDiv.innerHTML = `
            <div class="flex items-start justify-between mb-2">
              <div>
                <h4 class="font-mono text-sm font-medium text-slate-900">${test.testName}</h4>
                <div class="flex items-center gap-2 mt-1">
                  ${statusBadge(test.status, test.rfcLevel)}
                  <span class="text-xs text-slate-500">RFC Level: ${test.rfcLevel}</span>
                  <span class="text-xs text-slate-500 ${statusClass} font-medium">${test.status.toUpperCase()}${durationText}</span>
                </div>
              </div>
            </div>
            ${test.output ? `
              <div class="mt-3">
                <h5 class="text-xs font-medium text-slate-700 mb-1">Output:</h5>
                <pre class="text-xs bg-slate-50 p-2 rounded border overflow-x-auto text-slate-700">${test.output.trim()}</pre>
              </div>
            ` : ''}
            ${crossRefSection}
          `;

          section.appendChild(testDiv);
        }

        content.appendChild(section);
      }
    }

    function renderMatrix({ rows, senders, testDetails, startTime }, isComplete = true) {
      const thead = document.querySelector('thead tr');
      while (thead.children.length > 2) thead.removeChild(thead.lastChild);
      for (const sender of senders) {
        const th = document.createElement('th');
        th.className = 'px-4 py-2 font-semibold';
        th.textContent = sender;
        thead.appendChild(th);
      }

      const tbody = document.getElementById('tbody');
      tbody.innerHTML = '';

      for (const row of rows) {
        const tr = document.createElement('tr');
        tr.className = 'border-t border-slate-100 hover:bg-slate-50';

        const tdName = document.createElement('td');
        tdName.className = 'sticky left-0 z-[1] bg-white px-4 py-2 font-mono text-[13px]';
        tdName.textContent = row.testName;
        tr.appendChild(tdName);

        const tdLevel = document.createElement('td');
        tdLevel.className = 'px-4 py-2';
        const levelPill = document.createElement('span');
        levelPill.className = 'inline-block rounded bg-slate-100 px-2 py-0.5 font-medium text-slate-700';
        levelPill.textContent = row.rfcLevel;
        tdLevel.appendChild(levelPill);
        tr.appendChild(tdLevel);

        for (const sender of senders) {
          const td = document.createElement('td');
          td.className = 'px-4 py-2 whitespace-nowrap';
          const matchingDetail = testDetails.find(detail =>
            removeOneSegment(detail.testName, detail.sender) === row.testName && detail.sender === sender
          );
          const originalTestName = matchingDetail ? matchingDetail.testName : null;
          td.innerHTML = statusBadge(row.resultsBySender[sender], row.rfcLevel, originalTestName, sender);
          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      }

      const stats = {};
      for (const sender of senders) {
        stats[sender] = { mustPass: 0, mustFail: 0, shouldPass: 0, shouldFail: 0, mayPass: 0, mayFail: 0 };
      }

      for (const row of rows) {
        const rfcLevel = (row.rfcLevel || '').toUpperCase();
        for (const sender of senders) {
          const status = row.resultsBySender[sender];
          if (status === STATUS.PASS) {
            if (rfcLevel === 'MUST') stats[sender].mustPass++;
            else if (rfcLevel === 'SHOULD') stats[sender].shouldPass++;
            else if (rfcLevel === 'MAY') stats[sender].mayPass++;
          } else if (status === STATUS.FAIL) {
            if (rfcLevel === 'MUST') stats[sender].mustFail++;
            else if (rfcLevel === 'SHOULD') stats[sender].shouldFail++;
            else if (rfcLevel === 'MAY') stats[sender].mayFail++;
          }
        }
      }

      const tfoot = document.getElementById('tfoot');
      tfoot.innerHTML = '';

      const tr = document.createElement('tr');

      const tdName = document.createElement('td');
      tdName.className = 'sticky left-0 z-[1] bg-slate-100 px-4 py-2 font-semibold text-sm';
      tdName.textContent = 'Statistics';
      tr.appendChild(tdName);

      const tdLevel = document.createElement('td');
      tdLevel.className = 'px-4 py-2';
      tr.appendChild(tdLevel);

      for (const sender of senders) {
        const td = document.createElement('td');
        td.className = 'px-4 py-2 text-xs text-slate-700';
        const s = stats[sender];
        const isCompliant = s.mustFail === 0 && s.mustPass > 0;
        const complianceLabel = isComplete
          ? (isCompliant
              ? '<div class="mt-2"><span class="inline-block rounded px-2 py-1 bg-green-100 text-green-800 font-semibold text-xs">COMPLIANT</span></div>'
              : '<div class="mt-2"><span class="inline-block rounded px-2 py-1 bg-red-100 text-red-800 font-semibold text-xs">NOT COMPLIANT</span></div>')
          : '';

        const mustTotal = s.mustPass + s.mustFail;
        const shouldTotal = s.shouldPass + s.shouldFail;

        const mustPassPercent = mustTotal > 0 ? (s.mustPass / mustTotal) * 100 : 0;
        const shouldPassPercent = shouldTotal > 0 ? (s.shouldPass / shouldTotal) * 100 : 0;

        const mustProgressBar = mustTotal > 0 ? `
          <div class="mb-2">
            <div class="text-xs font-semibold mb-1">MUST: ${s.mustPass} OK, ${s.mustFail} FAIL</div>
            <div class="w-full bg-gray-300 rounded-full h-2">
              <div class="${mustPassPercent === 100 ? 'bg-green-500' : 'bg-gray-600'}${!isComplete ? ' progress-animated' : ''} h-2 rounded-full" style="width: ${mustPassPercent}%"></div>
            </div>
          </div>
        ` : '';

        const shouldProgressBar = shouldTotal > 0 ? `
          <div class="mb-2">
            <div class="text-xs font-semibold mb-1">SHOULD: ${s.shouldPass} OK, ${s.shouldFail} FAIL</div>
            <div class="w-full bg-gray-300 rounded-full h-2">
              <div class="bg-gray-600${!isComplete ? ' progress-animated' : ''} h-2 rounded-full" style="width: ${shouldPassPercent}%"></div>
            </div>
          </div>
        ` : '';

        const mayTotal = s.mayPass + s.mayFail;
        const mayPassPercent = mayTotal > 0 ? (s.mayPass / mayTotal) * 100 : 0;
        const mayProgressBar = mayTotal > 0 ? `
          <div class="mb-2">
            <div class="text-xs font-semibold mb-1">MAY: ${s.mayPass} OK, ${s.mayFail} FAIL</div>
            <div class="w-full bg-gray-300 rounded-full h-2">
              <div class="bg-gray-600${!isComplete ? ' progress-animated' : ''} h-2 rounded-full" style="width: ${mayPassPercent}%"></div>
            </div>
          </div>
        ` : '';

        td.innerHTML = `
          <div class="space-y-1">
            ${mustProgressBar}
            ${shouldProgressBar}
            ${mayProgressBar}
            ${complianceLabel}
          </div>
        `;
        tr.appendChild(td);
      }

      tfoot.appendChild(tr);

      const summary = document.getElementById('summary');
      const testS = rows.length === 1 ? '' : 's';
      const senderS = senders.length === 1 ? '' : 's';
      let summaryText = `${rows.length} test${testS} • ${senders.length} sender${senderS}`;
      if (startTime) {
        const date = new Date(startTime);
        const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: 'UTC', timeZoneName: 'short' };
        summaryText += ` • Started: ${date.toLocaleString('en-US', options)}`;
      }
      summary.textContent = summaryText;

      renderTestDetails(testDetails, senders, testDetails);

      document.getElementById('status').textContent = rows.length
        ? 'Showing tests that have both a sender and an rfcLevel attribute (with attribute inheritance by prefix).'
        : 'No matching tests found (need both sender and rfcLevel).';
    }

    // ---------- Loading ----------
    async function loadFromFetch() {
      const status = document.getElementById('status');
      status.textContent = 'Loading results.json…';
      const res = await fetch(`results.json?t=${Date.now()}`).catch(() => null);
      if (!res || !res.ok) throw new Error('results.json not found or not fetchable');
      const text = await res.text();
      const events = toLinesOrArray(text);

      const isComplete = checkResultsCompleteness(events);
      showIncompleteWarning(!isComplete);

      const matrix = buildMatrix(events);
      renderMatrix(matrix, isComplete);
      status.textContent = 'Loaded results.json.';
    }

    async function loadFromFile(file) {
      const status = document.getElementById('status');
      status.textContent = `Loading ${file.name}…`;
      const text = await file.text();
      const events = toLinesOrArray(text);

      const isComplete = checkResultsCompleteness(events);
      showIncompleteWarning(!isComplete);

      const matrix = buildMatrix(events);
      renderMatrix(matrix, isComplete);
      status.textContent = `Loaded ${file.name}.`;
    }

    // ---------- Back to Top Button ----------
    function initBackToTop() {
      const backToTopBtn = document.getElementById('backToTop');

      window.addEventListener('scroll', () => {
        if (window.scrollY > 300) {
          backToTopBtn.classList.remove('opacity-0', 'pointer-events-none');
          backToTopBtn.classList.add('opacity-100');
        } else {
          backToTopBtn.classList.add('opacity-0', 'pointer-events-none');
          backToTopBtn.classList.remove('opacity-100');
        }
      });

      backToTopBtn.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    }

    // ---------- Boot ----------
    (function boot() {
      initBackToTop();

      const hideSuccessCheckbox = document.getElementById('hideSuccessCheckbox');
      const hideShouldFailsCheckbox = document.getElementById('hideShouldFailsCheckbox');

      const savedHideSuccess = localStorage.getItem('hideSuccess');
      if (savedHideSuccess === 'true') {
        hideSuccessCheckbox.checked = true;
      }

      const savedHideShouldFails = localStorage.getItem('hideShouldFails');
      if (savedHideShouldFails === 'true') {
        hideShouldFailsCheckbox.checked = true;
      }

      let currentMatrix = null;

      const handleCheckboxChange = () => {
        localStorage.setItem('hideSuccess', hideSuccessCheckbox.checked.toString());
        localStorage.setItem('hideShouldFails', hideShouldFailsCheckbox.checked.toString());

        if (currentMatrix) {
          renderTestDetails(currentMatrix.testDetails, currentMatrix.senders, currentMatrix.testDetails);
        }
      };

      hideSuccessCheckbox.addEventListener('change', handleCheckboxChange);
      hideShouldFailsCheckbox.addEventListener('change', handleCheckboxChange);

      const originalRenderMatrix = renderMatrix;
      renderMatrix = function(matrix, isComplete) {
        currentMatrix = matrix;
        originalRenderMatrix(matrix, isComplete);
      };

      loadFromFetch().catch(() => {
        document.getElementById('status').textContent =
          'results.json not found via fetch — use "Load file…" or serve this directory.';
      });

      document.getElementById('reloadBtn').addEventListener('click', () => {
        loadFromFetch().catch(err => {
          document.getElementById('status').textContent =
            'Reload failed: results.json not found — use "Load file…".';
        });
      });

      document.getElementById('fileInput').addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (f) loadFromFile(f);
        e.target.value = '';
      });
    })();
  </script>
</body>
</html>
